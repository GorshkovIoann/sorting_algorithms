# Исследование Алгоритмов Сортировки
В данной работе будет разобрано несколько популярных алгоритмов сортировки массивов целых чисел и произведено сравнение скорости сортировки различных алгоритмов в зависимости от размера сортируемого массива.

## Содержание
- [Вступление](#вступление)
- [Bubble Sort](#bubble-sort)
- [Bubble Sort](#bubble-sort)
- [Bubble Sort](#bubble-sort)
- [Bubble Sort](#bubble-sort)
- [Bubble Sort](#bubble-sort)
- [Bubble Sort](#bubble-sort)
- [Bubble Sort](#bubble-sort)
- [Bubble Sort](#bubble-sort)
- [Bubble Sort](#bubble-sort)
- [Bubble Sort](#bubble-sort)

## <a id ="вступление">Вступление</a>
Сортировочные алгоритмы занимают особое место в истории и развитии информатики. Их цель заключается в упорядочении элементов массива или списка в определённой последовательности, например, по возрастанию или убыванию.  

В настоящее время существует множество различных сортировочных алгоритмов, каждый из которых имеет свои преимущества и недостатки в зависимости от конкретной задачи. Выбор подходящего алгоритма зависит от многих факторов, таких как объём данных, требуемая скорость сортировки, доступность памяти и другие особенности конкретной задачи.

В дальнейшем работе мы рассмотрим наиболее популярные и эффективные сортировочные алгоритмы, изучим их принципы работы, а также сравним их производительность и скорость работы.

## Bubble Sort
Bubble sort (также известен как сортировка пузырьком или сортировка с понижением) — это простой алгоритм сортировки, который работает путём повторяющихся проходов по массиву. На каждом проходе алгоритм сравнивает пары соседних элементов и меняет их местами, если они находятся в неправильном порядке. В результате каждого прохождения самое большое не отсортированное число будет становится на свое место так как при каждом сравнении алгоритм будет менять его местами со всеми остальными элементами неотсортировннаой части массива. Этот процесс продолжается до тех пор, пока массив не будет отсортирован. Алгоритм сортировки сравнения назван в честь того, как более крупные элементы «всплывают» вверх списка.

### Реализация на языке с++
```c++
 void bubbleSort(vector<int>& array){ 
  for (var i = 0; i < array.size() i++){
    bool swapped = false;
    for ( var j = 0; j < array.size() — i — 1; j++){
      if (array[j] > array[j + 1] ){
        swap(array[j], array[j + 1]);
        swapped = true;
      }
    }
    if(!swapped){break;}
  }
}
```
Функция работает следующим образом: так как в конце каждого прохода как минимум один элемент(наибольший из неотсортированных) встает на свое место, нам может потребоваться максимум n прохождений(первый цикл) по неотсортированной части массива(второй цикл, где -i отсортированная к этому моменту часть). При этом переменная swapped отвечает за проверку отсортированности массива. Если прохождение по массиву обошлось без перестановок - значит массив уже отсортирован и продолжать обход не имеет смысла. Оставшееся условие - это то самое сравнение двух соседних элементов и их перестановка в случае не соответствия порядка(в нашем случае порядка возрастания)

### Анализ сложности и памяти
Дополнительная память не требуется, наибольшая ее затрата - это выделение буфера для перестановки двух элементов. 

Расстояние и направление, в котором элементы должны двигаться во время сортировки, определяют производительность пузырьковой сортировки, поскольку элементы движутся в разных направлениях с разной скоростью. Элемент, который должен переместиться в конец списка, может перемещаться быстро, поскольку он может участвовать в последовательных заменах. Например, самый большой элемент в списке выиграет каждую замену, поэтому он переместится на отсортированную позицию при первом проходе, даже если он начинается ближе к началу. С другой стороны, элемент, который должен двигаться к началу списка, не может двигаться быстрее, чем на один шаг за проход, поэтому элементы движутся к началу очень медленно. Если наименьший элемент находится в конце списка, потребуется n - 1 шагов, чтобы переместить его в начало.

Исходя из этого худший случай - это убывающий массив. Тогда сложность: O((n-1) + (n-2) + ... + 1) = O(n^2). Лучший - возрастающий массив. В этом случае осознания бессмысленности происходящего придет ровно через n шагов и сложность соответственно будет О(n).

В среднем мы имеем (n-1) + (n-2) + ... + ... = n(n-1)/2. Отсюда средняя сложность также О(n)
## Источники
Если вы чем-то вдохновлялись, расскажите об этом: где брали идеи, какие туториалы смотрели, ссылки на исходники кода. 
