# Исследование Алгоритмов Сортировки
В данной работе будет разобрано несколько популярных алгоритмов сортировки массивов целых чисел и произведено сравнение скорости сортировки различных алгоритмов в зависимости от размера сортируемого массива.

## Содержание
- [Вступление](#вступление)
- [Bubble Sort](#bubble-sort)
- [Timsort](#timsort)
- [Gnome Sort](#gnome-sort)
- [Merge Sort](#merge-sort)
- [Сравнение эффективности алгоритмов](#сравнение-эффективности-алгоритмов)
- [Источники](#источники)


## <a id ="вступление">Вступление</a>
Сортировочные алгоритмы занимают особое место в истории и развитии информатики. Их цель заключается в упорядочении элементов массива или списка в определённой последовательности, например, по возрастанию или убыванию.  

В настоящее время существует множество различных сортировочных алгоритмов, каждый из которых имеет свои преимущества и недостатки в зависимости от конкретной задачи. Выбор подходящего алгоритма зависит от многих факторов, таких как объём данных, требуемая вычислительная сложность, доступность памяти и другие особенности конкретной задачи.

Вычислительная сложность — понятие в информатике и теории ал-горитмов, обозначающее  функцию зависимости  времени работы алго-ритма от размера входных данных. Для описания такой функции исполь-зуют заглавную букву «О». Сама функция может быть, например, линей-ной O(N), квадратичной O(N2), логарифмической O(log N), где N размер массива. Следует отметить, что оценка вычислительной сложности явля-ется асимптотическим показателем и используется при устремлении раз-мера сортируемого массива к бесконечности. Она позволяет предсказать время  выполнения  и  сравнивать эффективность  различных  алгоритмов друг с другом. При реальных объемах данных, эта оценка не может слу-жить для точных расчетов.  Многие алгоритмы предлагают выбор между объёмом памяти и ско-ростью. Задачу можно решить быстро, используя большой объём памяти, или медленнее, занимая меньший. При сравнении различных алгоритмов важно знать, как зависит объем затраченных ресурсов (объем  памяти  и время выполнения) от количества входных данных. Допустим,  при сор-тировке одним  методом  обработка десяти  тысячи  чисел занимает  1  секунду, а обработка миллиона чисел – 10 секунд, при использовании дру-гого алгоритма  может потребоваться две и пять секунд соответственно. В таких условиях нельзя однозначно сказать, какой алгоритм лучше, так как каждое  вычислительное  устройство  имеет  свои  особенности,  кото-рые могут влиять на длительность вычисления. Обычно при разработке алгоритма не берутся во внимание некоторые технические детали, такие как размер кэша процессора, тип многозадачности, реализуемый опера-ционной системой и др.

Анализ алгоритмов проводят на абстрактной модели, называемой ма-шиной  с  произвольным  доступом  к  памяти  (RAM). Модель  состоит из памяти и процессора, которые работают следующим образом: 
1. Память состоит из ячеек, каждая из которых имеет адрес и может хранить один элемент данных.
2. Каждое  обращение  к  памяти  занимает  одну  единицу  времени, независимо от номера адресуемой ячейки.
3. Количество  памяти  достаточно  для  выполнения  любого  алгоритма.
4. Процессор выполняет любую элементарную операцию (например, основные логические и арифметические операции, чтение из памяти, запись в память, вызов подпрограммы и т.п.) за один временной шаг.
5. Циклы и функции не считаются элементарными операциями. Такая модель  далека от реального компьютера, но она  замечательно подходит для анализа временной сложности алгоритмов.

Основные классы алгоритмов повышения на алгоритмах повторения и рекурсивные алгоритмы. В основе алгоритмов повторения операторов цикла и условных операторов. Анализ алгоритмов такого класса требует подсчета всех циклов и операций внутри них.

Рекурсивные алгоритмы строятся на основе математической рекурсивной функции. В языках программирования рекурсивной понижения называется программа-функция, которая обращается сама к себе. Рекурсивная программа не может продолжать себя бесконечно, поэтому второй важный момент обеспечивает рекурсивную программу - условия доступности, позволяющие выполнить программу остановки себя. Анализ рекурсивного алгоритма, как правило, сложнее. Он требует подсчета операций вызова рекурсивной функции, чтобы условия выполнения содержали рекурсию и подсчет операций внутри каждой вызванной рекурсивной функции.


В дальнейшем работе мы рассмотрим наиболее популярные и эффективные сортировочные алгоритмы, изучим их принципы работы, а также сравним их производительность и скорость работы.

## Bubble Sort
Bubble sort (также известен как сортировка пузырьком или сортировка с понижением) — это простой алгоритм сортировки, который работает путём повторяющихся проходов по массиву. На каждом проходе алгоритм сравнивает пары соседних элементов и меняет их местами, если они находятся в неправильном порядке. В результате каждого прохождения самое большое не отсортированное число будет становится на свое место так как при каждом сравнении алгоритм будет менять его местами со всеми остальными элементами неотсортировннаой части массива. Этот процесс продолжается до тех пор, пока массив не будет отсортирован. Алгоритм сортировки сравнения назван в честь того, как более крупные элементы «всплывают» вверх списка.

### Реализация на языке с++
```c++
 void bubbleSort(vector<int>& array){ 
  for (var i = 0; i < array.size() i++){
    bool swapped = false;
    for ( var j = 0; j < array.size() — i — 1; j++){
      if (array[j] > array[j + 1] ){
        swap(array[j], array[j + 1]);
        swapped = true;
      }
    }
    if(!swapped){break;}
  }
}
```
Функция работает следующим образом: так как в конце каждого прохода как минимум один элемент(наибольший из неотсортированных) встает на свое место, нам может потребоваться максимум n прохождений(первый цикл) по неотсортированной части массива(второй цикл, где -i отсортированная к этому моменту часть). При этом переменная swapped отвечает за проверку отсортированности массива. Если прохождение по массиву обошлось без перестановок - значит массив уже отсортирован и продолжать обход не имеет смысла. Оставшееся условие - это то самое сравнение двух соседних элементов и их перестановка в случае не соответствия порядка(в нашем случае порядка возрастания)

### Анализ сложности и памяти
Дополнительная память не требуется, наибольшая ее затрата - это выделение буфера для перестановки двух элементов. 

Расстояние и направление, в котором элементы должны двигаться во время сортировки, определяют производительность пузырьковой сортировки, поскольку элементы движутся в разных направлениях с разной скоростью. Элемент, который должен переместиться в конец списка, может перемещаться быстро, поскольку он может участвовать в последовательных заменах. Например, самый большой элемент в списке выиграет каждую замену, поэтому он переместится на отсортированную позицию при первом проходе, даже если он начинается ближе к началу. С другой стороны, элемент, который должен двигаться к началу списка, не может двигаться быстрее, чем на один шаг за проход, поэтому элементы движутся к началу очень медленно. Если наименьший элемент находится в конце списка, потребуется n - 1 шагов, чтобы переместить его в начало.

Исходя из этого худший случай - это убывающий массив. Тогда сложность: O((n-1) + (n-2) + ... + 1) = O(n^2). Лучший - возрастающий массив. В этом случае осознания бессмысленности происходящего придет ровно через n шагов и сложность соответственно будет О(n).

В среднем мы имеем (n-1) + (n-2) + ... + ... = n(n-1)/2. Отсюда средняя сложность также О(n)

---

## Timsort

### Реализация на языке с++

### Анализ сложности и памяти

---

## Gnome Sort

### Реализация на языке с++

### Анализ сложности и памяти

---

## Merge Sort

### Реализация на языке с++

### Анализ сложности и памяти

---

## Источники

