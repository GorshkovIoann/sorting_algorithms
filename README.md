# Исследование Алгоритмов Сортировки
В данной работе будет разобрано несколько популярных алгоритмов сортировки массивов целых чисел и произведено сравнение скорости сортировки различных алгоритмов в зависимости от размера сортируемого массива.

## Содержание
- [Вступление](#вступление)
- [Bubble Sort](#bubble-sort)
- [Merge Sort](#merge-sort)
- [Insertion sort](#insertion-sort)
- [Timsort](#timsort)
- [Gnome Sort](#gnome-sort)
- [Odd-Even Sort](#odd-even-sort)
- [Radix Sort](#radix-sort)
- [Heap Sort](#heap-sort)
- [Selection Sort](#selection-sort)
- [Cycle Sort](#cycle-sort)
- [Сравнение эффективности алгоритмов](#сравнение-эффективности-алгоритмов)
- [Источники](#источники)


## <a id ="вступление">Вступление</a>
Сортировочные алгоритмы занимают особое место в истории и развитии информатики. Их цель заключается в упорядочении элементов массива или списка в определённой последовательности, например, по возрастанию или убыванию.  

В настоящее время существует множество различных сортировочных алгоритмов, каждый из которых имеет свои преимущества и недостатки в зависимости от конкретной задачи. Выбор подходящего алгоритма зависит от многих факторов, таких как объём данных, требуемая вычислительная сложность, доступность памяти и другие особенности конкретной задачи.

Вычислительная сложность — понятие в информатике и теории ал-горитмов, обозначающее  функцию зависимости  времени работы алго-ритма от размера входных данных. Для описания такой функции исполь-зуют заглавную букву «О». Сама функция может быть, например, линей-ной O(N), квадратичной O(N2), логарифмической O(log N), где N размер массива. Следует отметить, что оценка вычислительной сложности явля-ется асимптотическим показателем и используется при устремлении раз-мера сортируемого массива к бесконечности. Она позволяет предсказать время  выполнения  и  сравнивать эффективность  различных  алгоритмов друг с другом. При реальных объемах данных, эта оценка не может слу-жить для точных расчетов.  Многие алгоритмы предлагают выбор между объёмом памяти и ско-ростью. Задачу можно решить быстро, используя большой объём памяти, или медленнее, занимая меньший. При сравнении различных алгоритмов важно знать, как зависит объем затраченных ресурсов (объем  памяти  и время выполнения) от количества входных данных. Допустим,  при сор-тировке одним  методом  обработка десяти  тысячи  чисел занимает  1  секунду, а обработка миллиона чисел – 10 секунд, при использовании дру-гого алгоритма  может потребоваться две и пять секунд соответственно. В таких условиях нельзя однозначно сказать, какой алгоритм лучше, так как каждое  вычислительное  устройство  имеет  свои  особенности,  кото-рые могут влиять на длительность вычисления. Обычно при разработке алгоритма не берутся во внимание некоторые технические детали, такие как размер кэша процессора, тип многозадачности, реализуемый опера-ционной системой и др.

Анализ алгоритмов проводят на абстрактной модели, называемой ма-шиной  с  произвольным  доступом  к  памяти  (RAM). Модель  состоит из памяти и процессора, которые работают следующим образом: 
1. Память состоит из ячеек, каждая из которых имеет адрес и может хранить один элемент данных.
2. Каждое  обращение  к  памяти  занимает  одну  единицу  времени, независимо от номера адресуемой ячейки.
3. Количество  памяти  достаточно  для  выполнения  любого  алгоритма.
4. Процессор выполняет любую элементарную операцию (например, основные логические и арифметические операции, чтение из памяти, запись в память, вызов подпрограммы и т.п.) за один временной шаг.
5. Циклы и функции не считаются элементарными операциями. Такая модель  далека от реального компьютера, но она  замечательно подходит для анализа временной сложности алгоритмов.

Основные классы алгоритмов повышения на алгоритмах повторения и рекурсивные алгоритмы. В основе алгоритмов повторения операторов цикла и условных операторов. Анализ алгоритмов такого класса требует подсчета всех циклов и операций внутри них.

Рекурсивные алгоритмы строятся на основе математической рекурсивной функции. В языках программирования рекурсивной понижения называется программа-функция, которая обращается сама к себе. Рекурсивная программа не может продолжать себя бесконечно, поэтому второй важный момент обеспечивает рекурсивную программу - условия доступности, позволяющие выполнить программу остановки себя. Анализ рекурсивного алгоритма, как правило, сложнее. Он требует подсчета операций вызова рекурсивной функции, чтобы условия выполнения содержали рекурсию и подсчет операций внутри каждой вызванной рекурсивной функции.


В дальнейшем работе мы рассмотрим наиболее популярные и эффективные сортировочные алгоритмы, изучим их принципы работы, а также сравним их производительность и скорость работы.

## Bubble Sort
Bubble sort (также известен как сортировка пузырьком или сортировка с понижением) — это простой алгоритм сортировки, который работает путём повторяющихся проходов по массиву. На каждом проходе алгоритм сравнивает пары соседних элементов и меняет их местами, если они находятся в неправильном порядке. В результате каждого прохождения самое большое не отсортированное число будет становится на свое место так как при каждом сравнении алгоритм будет менять его местами со всеми остальными элементами неотсортировннаой части массива. Этот процесс продолжается до тех пор, пока массив не будет отсортирован. Алгоритм сортировки сравнения назван в честь того, как более крупные элементы «всплывают» вверх списка.

### Реализация на языке с++
```c++
 void bubbleSort(vector<int>& array){ 
  for (var i = 0; i < array.size() i++){
    bool swapped = false;
    for ( var j = 0; j < array.size() — i — 1; j++){
      if (array[j] > array[j + 1] ){
        swap(array[j], array[j + 1]);
        swapped = true;
      }
    }
    if(!swapped){break;}
  }
}
```
Функция работает следующим образом: так как в конце каждого прохода как минимум один элемент(наибольший из неотсортированных) встает на свое место, нам может потребоваться максимум n прохождений(первый цикл) по неотсортированной части массива(второй цикл, где -i отсортированная к этому моменту часть). При этом переменная swapped отвечает за проверку отсортированности массива. Если прохождение по массиву обошлось без перестановок - значит массив уже отсортирован и продолжать обход не имеет смысла. Оставшееся условие - это то самое сравнение двух соседних элементов и их перестановка в случае не соответствия порядка(в нашем случае порядка возрастания)

### Анализ сложности и памяти
Дополнительная память не требуется, наибольшая ее затрата - это выделение буфера для перестановки двух элементов. 

Расстояние и направление, в котором элементы должны двигаться во время сортировки, определяют производительность пузырьковой сортировки, поскольку элементы движутся в разных направлениях с разной скоростью. Элемент, который должен переместиться в конец списка, может перемещаться быстро, поскольку он может участвовать в последовательных заменах. Например, самый большой элемент в списке выиграет каждую замену, поэтому он переместится на отсортированную позицию при первом проходе, даже если он начинается ближе к началу. С другой стороны, элемент, который должен двигаться к началу списка, не может двигаться быстрее, чем на один шаг за проход, поэтому элементы движутся к началу очень медленно. Если наименьший элемент находится в конце списка, потребуется n - 1 шагов, чтобы переместить его в начало.

Исходя из этого худший случай - это убывающий массив. Тогда сложность: O((n-1) + (n-2) + ... + 1) = O(n^2). Лучший - возрастающий массив. В этом случае осознания бессмысленности происходящего придет ровно через n шагов и сложность соответственно будет О(n).

В среднем мы имеем (n-1) + (n-2) + ... + ... = n(n-1)/2. Отсюда средняя сложность также О(n)

---

## Merge Sort

Merge sort (Сортировка слиянием)  — алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке.

При сортировке сначала массив разбивается на несколько подмассивов меньшего размера. Затем эти подмассивы сортируются с помощью рекурсивного вызова или непосредственно, если их размер достаточно мал(обычно размер будет равен единице). Наконец, их решения комбинируются, и получается решение исходной задачи.
### Реализация на языке с++
```c++
using namespace std;

//функция слияния двух подмассивов в массив.
// первый подмассив arr[begin..mid]
// второй подмассив arr[mid+1..end]
void merge(int array[], int const left, int const mid, int const right)
{
    int const subArrayOne = mid - left + 1;
    int const subArrayTwo = right - mid;

    // создание временных массивов
    auto *leftArray = new int[subArrayOne],
         *rightArray = new int[subArrayTwo];

    // заполняем первой половиной исходного массива первый временный массив
    // второй половиной второй временный массив
    for (auto i = 0; i < subArrayOne; i++)
        leftArray[i] = array[left + i];
    for (auto j = 0; j < subArrayTwo; j++)
        rightArray[j] = array[mid + 1 + j];

    auto indexOfSubArrayOne = 0, indexOfSubArrayTwo = 0;
    int indexOfMergedArray = left;

    // сливаем два массива обратно в array[left..right]
    // с помощьюдвух указателей бегущих от начала временных массивов
    // и заполняющих array наимаеньшим из двух элементов
    // при этом передвигая указатель на этот элемент на +1
    while (indexOfSubArrayOne < subArrayOne
           && indexOfSubArrayTwo < subArrayTwo) {
        if (leftArray[indexOfSubArrayOne]
            <= rightArray[indexOfSubArrayTwo]) {
            array[indexOfMergedArray]
                = leftArray[indexOfSubArrayOne];
            indexOfSubArrayOne++;
        }
        else {
            array[indexOfMergedArray]
                = rightArray[indexOfSubArrayTwo];
            indexOfSubArrayTwo++;
        }
        indexOfMergedArray++;
    }

    // Копируем оставшиеся элементы 
    // leftArray[], ecли они есть
    while (indexOfSubArrayOne < subArrayOne) {
        array[indexOfMergedArray]
            = leftArray[indexOfSubArrayOne];
        indexOfSubArrayOne++;
        indexOfMergedArray++;
    }

    // Копируем оставшиеся элементы 
    // rightArray[], ecли они есть
    while (indexOfSubArrayTwo < subArrayTwo) {
        array[indexOfMergedArray]
            = rightArray[indexOfSubArrayTwo];
        indexOfSubArrayTwo++;
        indexOfMergedArray++;
    }
    delete[] leftArray;
    delete[] rightArray;
}

// begin - индекс первого элемента, end - индекс последнего
void mergeSort(int array[], int const begin, int const end)
{
    if (begin >= end)
        return;

    int mid = begin + (end - begin) / 2;
    mergeSort(array, begin, mid);
    mergeSort(array, mid + 1, end);
    merge(array, begin, mid, end);
}
```


1. Массив рекурсивно разбивается пополам, и каждая из половин делится пополам до тех пор, пока размер подмассива не станет равным единице.
2. Выполняется операция алгоритма, называемая слиянием. Два подмассива сливаются в общий результирующий массив, при этом  из  каждого выбирается меньший элемент (сортировка по возрастанию) и записывается  в  свободную  левую  ячейку результирующего  массива(Действительно, таким образом можно превратить два отсортированных массива в 1 отсортированный, так как на каждом шаге в результирующий массив будет записываться наименьший из еще не записанных элементов). В случае если один из массивов закончится, элементы другого записываются в массив, где они собираются.
3. Элементы  перезаписываются  из результирующего  массива  в  исходный. 

### Анализ сложности и памяти
Память: для создания двух временных подмассивов длинной n/2 на каждом шаге нам потребуется ровно n ячеек памяти и так как сортировка происходит не на месте нам также нужна дополнительная память на копию массива или другими словами merge sort требует O(n) памяти.

Оценим сложность: Пусть Т(n) - время сортировки массива длины n. Тогда Т(n) = 2T(n/2) + время выполнения п.2. Время выполнения п.2 равно времени за которое два указателя пройдут массивы длинной n/2 = O(n). Тогда T(n) = 2T(n/2) + O(n) = logn * T(1) + logn * O(n) = O(nlogn). 
То есть вне зависимости от изначального состояния массива его сортировка занимает O(nlogn) времени.

---

## Insertion Sort

Insertion sort(сортировка вставками) - один из первых устойчивых видов сортировки. Идея заключается в следующем: есть часть массива, которая уже отсортирована, и требуется вставить остальные элементы массива в отсортированную часть, сохранив при этом упорядоченность. Для этого на каждом шаге алгоритма мы выбираем один из элементов входных данных и вставляем его на нужную позицию в уже отсортированной части массива, до тех пор пока весь набор входных данных не будет отсортирован. Метод выбора очередного элемента из исходного массива произволен, однако обычно (и с целью получения устойчивого алгоритма сортировки), элементы вставляются по порядку их появления во входном массиве.

### Реализация на языке с++

```c++
using namespace std;

//функция сортировки вставками
void insertionSort(int arr[], int n)
{
    int i, key, j;
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;

        // двигаем элементы arr[0..i-1],
        // которые больше чем key, 
        // на одну позицию вперед
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        //вставляем key позади больших его элементов
        arr[j + 1] = key;
    }
}

```

- Нам нужно начать со второго элемента массива, поскольку предполагается, что первый элемент массива отсортирован.
- Сравните второй элемент с первым элементом и проверьте, меньше ли второй элемент, а затем поменяйте их местами.
- Перейдите к третьему элементу и сравните его со вторым элементом, затем с первым элементом и поменяйте местами, если необходимо, чтобы поместить его в правильное положение среди первых трех элементов.
- Продолжайте этот процесс, сравнивая каждый элемент с предыдущими и меняя их местами по мере необходимости, чтобы разместить его в правильном положении среди отсортированных элементов.
- Повторяйте, пока весь массив не будет отсортирован.

### Анализ сложности и памяти

Память: необходимо создать лишь 3 буферные переменные => паямть = О(1).

Оценим сложность: Так как в процессе работы алгоритма могут меняться местами только соседние элементы, каждый обмен уменьшает число инверсий на единицу. Следовательно, количество обменов равно количеству инверсий в исходном массиве вне зависимости от реализации сортировки. Максимальное количество инверсий содержится в массиве, элементы которого отсортированы по невозрастанию. Число инверсий в таком массиве = n(n-1)/2
Получается алгоритм работает за О(n + k),  где k - число инверсий, то есть за 
О(n+n^2) = O(n^2), так как число инверсий можно ограничить n^2.

---


## Timsort

### Реализация на языке с++

### Анализ сложности и памяти

---

## Gnome Sort

### Реализация на языке с++

### Анализ сложности и памяти

---

## Odd-Even Sort

### Реализация на языке с++

### Анализ сложности и памяти

---

## Radix Sort

### Реализация на языке с++

### Анализ сложности и памяти

---

## Heap Sort

### Реализация на языке с++

### Анализ сложности и памяти

---

## Selection Sort

### Реализация на языке с++

### Анализ сложности и памяти

---

## Cycle Sort

### Реализация на языке с++

### Анализ сложности и памяти

---


## Источники

